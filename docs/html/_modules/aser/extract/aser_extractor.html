

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>aser.extract.aser_extractor &mdash; ASER 2.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> ASER
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Tutorial</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/get-started.html">Get Started</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/database.html">Database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/extractor.html">Extractor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/conceptualizer.html">Conceptualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/aser-cs.html">Server/Client</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ASER</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>aser.extract.aser_extractor</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for aser.extract.aser_extractor</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">aser.extract.eventuality_extractor</span> <span class="kn">import</span> <span class="n">SeedRuleEventualityExtractor</span><span class="p">,</span> <span class="n">DiscourseEventualityExtractor</span>
<span class="kn">from</span> <span class="nn">aser.extract.relation_extractor</span> <span class="kn">import</span> <span class="n">SeedRuleRelationExtractor</span><span class="p">,</span> <span class="n">DiscourseRelationExtractor</span>
<span class="kn">from</span> <span class="nn">aser.extract.utils</span> <span class="kn">import</span> <span class="n">parse_sentense_with_stanford</span><span class="p">,</span> <span class="n">get_corenlp_client</span>
<span class="kn">from</span> <span class="nn">aser.extract.utils</span> <span class="kn">import</span> <span class="n">ANNOTATORS</span>


<div class="viewcode-block" id="BaseASERExtractor"><a class="viewcode-back" href="../../../api/extractor.html#aser.extract.aser_extractor.BaseASERExtractor">[docs]</a><span class="k">class</span> <span class="nc">BaseASERExtractor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Base ASER Extractor to extract both eventualities and relations.</span>
<span class="sd">    It includes an instance of `BaseEventualityExtractor` and an instance of `BaseRelationExtractor`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corenlp_path</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">corenlp_port</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param corenlp_path: corenlp path, e.g., /home/xliucr/stanford-corenlp-3.9.2</span>
<span class="sd">        :type corenlp_path: str (default = &quot;&quot;)</span>
<span class="sd">        :param corenlp_port: corenlp port, e.g., 9000</span>
<span class="sd">        :type corenlp_port: int (default = 0)</span>
<span class="sd">        :param kw: other parameters</span>
<span class="sd">        :type kw: Dict[str, object]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">corenlp_path</span> <span class="o">=</span> <span class="n">corenlp_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corenlp_port</span> <span class="o">=</span> <span class="n">corenlp_port</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotators</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;annotators&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">ANNOTATORS</span><span class="p">))</span>

        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_externel_corenlp</span> <span class="o">=</span> <span class="n">get_corenlp_client</span><span class="p">(</span><span class="n">corenlp_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corenlp_path</span><span class="p">,</span> <span class="n">corenlp_port</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corenlp_port</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">eventuality_extractor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relation_extractor</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="BaseASERExtractor.close"><a class="viewcode-back" href="../../../api/extractor.html#aser.extract.aser_extractor.BaseASERExtractor.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Close the extractor safely</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_externel_corenlp</span><span class="p">:</span>
            <span class="n">corenlp_client</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_corenlp_client</span><span class="p">(</span><span class="n">corenlp_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corenlp_path</span><span class="p">,</span> <span class="n">corenlp_port</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corenlp_port</span><span class="p">)</span>
            <span class="n">corenlp_client</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eventuality_extractor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eventuality_extractor</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">relation_extractor</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relation_extractor</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<div class="viewcode-block" id="BaseASERExtractor.parse_text"><a class="viewcode-back" href="../../../api/extractor.html#aser.extract.aser_extractor.BaseASERExtractor.parse_text">[docs]</a>    <span class="k">def</span> <span class="nf">parse_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">annotators</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parse a raw text by corenlp</span>

<span class="sd">        :param text: a raw text</span>
<span class="sd">        :type text: str</span>
<span class="sd">        :param annotators: annotators for corenlp, please refer to https://stanfordnlp.github.io/CoreNLP/annotators.html</span>
<span class="sd">        :type annotators: Union[List, None] (default = None)</span>
<span class="sd">        :return: the parsed result</span>
<span class="sd">        :rtype: List[Dict[str, object]]</span>

<span class="sd">        .. highlight:: python</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            Input:</span>

<span class="sd">            &quot;My army will find your boat. In the meantime, I&#39;m sure we could find you suitable accommodations.&quot;</span>

<span class="sd">            Output:</span>

<span class="sd">            [{&#39;dependencies&#39;: [(1, &#39;nmod:poss&#39;, 0),</span>
<span class="sd">                               (3, &#39;nsubj&#39;, 1),</span>
<span class="sd">                               (3, &#39;aux&#39;, 2),</span>
<span class="sd">                               (3, &#39;dobj&#39;, 5),</span>
<span class="sd">                               (3, &#39;punct&#39;, 6),</span>
<span class="sd">                               (5, &#39;nmod:poss&#39;, 4)],</span>
<span class="sd">              &#39;lemmas&#39;: [&#39;my&#39;, &#39;army&#39;, &#39;will&#39;, &#39;find&#39;, &#39;you&#39;, &#39;boat&#39;, &#39;.&#39;],</span>
<span class="sd">              &#39;mentions&#39;: [],</span>
<span class="sd">              &#39;ners&#39;: [&#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;],</span>
<span class="sd">              &#39;parse&#39;: &#39;(ROOT (S (NP (PRP$ My) (NN army)) (VP (MD will) (VP (VB find) (NP &#39;</span>
<span class="sd">                       &#39;(PRP$ your) (NN boat)))) (. .)))&#39;,</span>
<span class="sd">              &#39;pos_tags&#39;: [&#39;PRP$&#39;, &#39;NN&#39;, &#39;MD&#39;, &#39;VB&#39;, &#39;PRP$&#39;, &#39;NN&#39;, &#39;.&#39;],</span>
<span class="sd">              &#39;text&#39;: &#39;My army will find your boat.&#39;,</span>
<span class="sd">              &#39;tokens&#39;: [&#39;My&#39;, &#39;army&#39;, &#39;will&#39;, &#39;find&#39;, &#39;your&#39;, &#39;boat&#39;, &#39;.&#39;]},</span>
<span class="sd">             {&#39;dependencies&#39;: [(2, &#39;case&#39;, 0),</span>
<span class="sd">                               (2, &#39;det&#39;, 1),</span>
<span class="sd">                               (6, &#39;nmod:in&#39;, 2),</span>
<span class="sd">                               (6, &#39;punct&#39;, 3),</span>
<span class="sd">                               (6, &#39;nsubj&#39;, 4),</span>
<span class="sd">                               (6, &#39;cop&#39;, 5),</span>
<span class="sd">                               (6, &#39;ccomp&#39;, 9),</span>
<span class="sd">                               (6, &#39;punct&#39;, 13),</span>
<span class="sd">                               (9, &#39;nsubj&#39;, 7),</span>
<span class="sd">                               (9, &#39;aux&#39;, 8),</span>
<span class="sd">                               (9, &#39;iobj&#39;, 10),</span>
<span class="sd">                               (9, &#39;dobj&#39;, 12),</span>
<span class="sd">                               (12, &#39;amod&#39;, 11)],</span>
<span class="sd">              &#39;lemmas&#39;: [&#39;in&#39;,</span>
<span class="sd">                         &#39;the&#39;,</span>
<span class="sd">                         &#39;meantime&#39;,</span>
<span class="sd">                         &#39;,&#39;,</span>
<span class="sd">                         &#39;I&#39;,</span>
<span class="sd">                         &#39;be&#39;,</span>
<span class="sd">                         &#39;sure&#39;,</span>
<span class="sd">                         &#39;we&#39;,</span>
<span class="sd">                         &#39;could&#39;,</span>
<span class="sd">                         &#39;find&#39;,</span>
<span class="sd">                         &#39;you&#39;,</span>
<span class="sd">                         &#39;suitable&#39;,</span>
<span class="sd">                         &#39;accommodation&#39;,</span>
<span class="sd">                         &#39;.&#39;],</span>
<span class="sd">              &#39;mentions&#39;: [],</span>
<span class="sd">              &#39;ners&#39;: [&#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;],</span>
<span class="sd">              &#39;parse&#39;: &#39;(ROOT (S (PP (IN In) (NP (DT the) (NN meantime))) (, ,) (NP (PRP &#39;</span>
<span class="sd">                       &quot;I)) (VP (VBP &#39;m) (ADJP (JJ sure) (SBAR (S (NP (PRP we)) (VP (MD &quot;</span>
<span class="sd">                       &#39;could) (VP (VB find) (NP (PRP you)) (NP (JJ suitable) (NNS &#39;</span>
<span class="sd">                       &#39;accommodations)))))))) (. .)))&#39;,</span>
<span class="sd">              &#39;pos_tags&#39;: [&#39;IN&#39;,</span>
<span class="sd">                           &#39;DT&#39;,</span>
<span class="sd">                           &#39;NN&#39;,</span>
<span class="sd">                           &#39;,&#39;,</span>
<span class="sd">                           &#39;PRP&#39;,</span>
<span class="sd">                           &#39;VBP&#39;,</span>
<span class="sd">                           &#39;JJ&#39;,</span>
<span class="sd">                           &#39;PRP&#39;,</span>
<span class="sd">                           &#39;MD&#39;,</span>
<span class="sd">                           &#39;VB&#39;,</span>
<span class="sd">                           &#39;PRP&#39;,</span>
<span class="sd">                           &#39;JJ&#39;,</span>
<span class="sd">                           &#39;NNS&#39;,</span>
<span class="sd">                           &#39;.&#39;],</span>
<span class="sd">              &#39;text&#39;: &quot;In the meantime, I&#39;m sure we could find you suitable &quot;</span>
<span class="sd">                      &#39;accommodations.&#39;,</span>
<span class="sd">              &#39;tokens&#39;: [&#39;In&#39;,</span>
<span class="sd">                         &#39;the&#39;,</span>
<span class="sd">                         &#39;meantime&#39;,</span>
<span class="sd">                         &#39;,&#39;,</span>
<span class="sd">                         &#39;I&#39;,</span>
<span class="sd">                         &quot;&#39;m&quot;,</span>
<span class="sd">                         &#39;sure&#39;,</span>
<span class="sd">                         &#39;we&#39;,</span>
<span class="sd">                         &#39;could&#39;,</span>
<span class="sd">                         &#39;find&#39;,</span>
<span class="sd">                         &#39;you&#39;,</span>
<span class="sd">                         &#39;suitable&#39;,</span>
<span class="sd">                         &#39;accommodations&#39;,</span>
<span class="sd">                         &#39;.&#39;]}]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">annotators</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">annotators</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotators</span>

        <span class="n">corenlp_client</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_corenlp_client</span><span class="p">(</span>
            <span class="n">corenlp_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corenlp_path</span><span class="p">,</span> <span class="n">corenlp_port</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corenlp_port</span><span class="p">,</span> <span class="n">annotators</span><span class="o">=</span><span class="n">annotators</span>
        <span class="p">)</span>
        <span class="n">parsed_result</span> <span class="o">=</span> <span class="n">parse_sentense_with_stanford</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">corenlp_client</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotators</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parsed_result</span></div>

<div class="viewcode-block" id="BaseASERExtractor.extract_eventualities_from_parsed_result"><a class="viewcode-back" href="../../../api/extractor.html#aser.extract.aser_extractor.BaseASERExtractor.extract_eventualities_from_parsed_result">[docs]</a>    <span class="k">def</span> <span class="nf">extract_eventualities_from_parsed_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parsed_result</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="s2">&quot;Eventuality&quot;</span><span class="p">,</span> <span class="n">in_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Extract eventualities from the parsed result</span>

<span class="sd">        :param parsed_result: the parsed result returned by corenlp</span>
<span class="sd">        :type parsed_result: List[Dict[str, object]]</span>
<span class="sd">        :param output_format: which format to return, &quot;Eventuality&quot; or &quot;json&quot;</span>
<span class="sd">        :type output_format: str (default = &quot;Eventuality&quot;)</span>
<span class="sd">        :param in_order: whether the returned order follows the input token order</span>
<span class="sd">        :type in_order: bool (default = True)</span>
<span class="sd">        :param kw: other parameters</span>
<span class="sd">        :type kw: Dict[str, object]</span>
<span class="sd">        :return: the extracted eventualities</span>
<span class="sd">        :rtype: Union[List[List[aser.eventuality.Eventuality]], List[List[Dict[str, object]]], List[aser.eventuality.Eventuality], List[Dict[str, object]]]</span>

<span class="sd">        .. highlight:: python</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            Input:</span>

<span class="sd">            [{&#39;dependencies&#39;: [(1, &#39;nmod:poss&#39;, 0),</span>
<span class="sd">                               (3, &#39;nsubj&#39;, 1),</span>
<span class="sd">                               (3, &#39;aux&#39;, 2),</span>
<span class="sd">                               (3, &#39;dobj&#39;, 5),</span>
<span class="sd">                               (3, &#39;punct&#39;, 6),</span>
<span class="sd">                               (5, &#39;nmod:poss&#39;, 4)],</span>
<span class="sd">              &#39;lemmas&#39;: [&#39;my&#39;, &#39;army&#39;, &#39;will&#39;, &#39;find&#39;, &#39;you&#39;, &#39;boat&#39;, &#39;.&#39;],</span>
<span class="sd">              &#39;mentions&#39;: [],</span>
<span class="sd">              &#39;ners&#39;: [&#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;],</span>
<span class="sd">              &#39;parse&#39;: &#39;(ROOT (S (NP (PRP$ My) (NN army)) (VP (MD will) (VP (VB find) (NP &#39;</span>
<span class="sd">                       &#39;(PRP$ your) (NN boat)))) (. .)))&#39;,</span>
<span class="sd">              &#39;pos_tags&#39;: [&#39;PRP$&#39;, &#39;NN&#39;, &#39;MD&#39;, &#39;VB&#39;, &#39;PRP$&#39;, &#39;NN&#39;, &#39;.&#39;],</span>
<span class="sd">              &#39;text&#39;: &#39;My army will find your boat.&#39;,</span>
<span class="sd">              &#39;tokens&#39;: [&#39;My&#39;, &#39;army&#39;, &#39;will&#39;, &#39;find&#39;, &#39;your&#39;, &#39;boat&#39;, &#39;.&#39;]},</span>
<span class="sd">             {&#39;dependencies&#39;: [(2, &#39;case&#39;, 0),</span>
<span class="sd">                               (2, &#39;det&#39;, 1),</span>
<span class="sd">                               (6, &#39;nmod:in&#39;, 2),</span>
<span class="sd">                               (6, &#39;punct&#39;, 3),</span>
<span class="sd">                               (6, &#39;nsubj&#39;, 4),</span>
<span class="sd">                               (6, &#39;cop&#39;, 5),</span>
<span class="sd">                               (6, &#39;ccomp&#39;, 9),</span>
<span class="sd">                               (6, &#39;punct&#39;, 13),</span>
<span class="sd">                               (9, &#39;nsubj&#39;, 7),</span>
<span class="sd">                               (9, &#39;aux&#39;, 8),</span>
<span class="sd">                               (9, &#39;iobj&#39;, 10),</span>
<span class="sd">                               (9, &#39;dobj&#39;, 12),</span>
<span class="sd">                               (12, &#39;amod&#39;, 11)],</span>
<span class="sd">              &#39;lemmas&#39;: [&#39;in&#39;,</span>
<span class="sd">                         &#39;the&#39;,</span>
<span class="sd">                         &#39;meantime&#39;,</span>
<span class="sd">                         &#39;,&#39;,</span>
<span class="sd">                         &#39;I&#39;,</span>
<span class="sd">                         &#39;be&#39;,</span>
<span class="sd">                         &#39;sure&#39;,</span>
<span class="sd">                         &#39;we&#39;,</span>
<span class="sd">                         &#39;could&#39;,</span>
<span class="sd">                         &#39;find&#39;,</span>
<span class="sd">                         &#39;you&#39;,</span>
<span class="sd">                         &#39;suitable&#39;,</span>
<span class="sd">                         &#39;accommodation&#39;,</span>
<span class="sd">                         &#39;.&#39;],</span>
<span class="sd">              &#39;mentions&#39;: [],</span>
<span class="sd">              &#39;ners&#39;: [&#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;],</span>
<span class="sd">              &#39;parse&#39;: &#39;(ROOT (S (PP (IN In) (NP (DT the) (NN meantime))) (, ,) (NP (PRP &#39;</span>
<span class="sd">                       &quot;I)) (VP (VBP &#39;m) (ADJP (JJ sure) (SBAR (S (NP (PRP we)) (VP (MD &quot;</span>
<span class="sd">                       &#39;could) (VP (VB find) (NP (PRP you)) (NP (JJ suitable) (NNS &#39;</span>
<span class="sd">                       &#39;accommodations)))))))) (. .)))&#39;,</span>
<span class="sd">              &#39;pos_tags&#39;: [&#39;IN&#39;,</span>
<span class="sd">                           &#39;DT&#39;,</span>
<span class="sd">                           &#39;NN&#39;,</span>
<span class="sd">                           &#39;,&#39;,</span>
<span class="sd">                           &#39;PRP&#39;,</span>
<span class="sd">                           &#39;VBP&#39;,</span>
<span class="sd">                           &#39;JJ&#39;,</span>
<span class="sd">                           &#39;PRP&#39;,</span>
<span class="sd">                           &#39;MD&#39;,</span>
<span class="sd">                           &#39;VB&#39;,</span>
<span class="sd">                           &#39;PRP&#39;,</span>
<span class="sd">                           &#39;JJ&#39;,</span>
<span class="sd">                           &#39;NNS&#39;,</span>
<span class="sd">                           &#39;.&#39;],</span>
<span class="sd">              &#39;text&#39;: &quot;In the meantime, I&#39;m sure we could find you suitable &quot;</span>
<span class="sd">                      &#39;accommodations.&#39;,</span>
<span class="sd">              &#39;tokens&#39;: [&#39;In&#39;,</span>
<span class="sd">                         &#39;the&#39;,</span>
<span class="sd">                         &#39;meantime&#39;,</span>
<span class="sd">                         &#39;,&#39;,</span>
<span class="sd">                         &#39;I&#39;,</span>
<span class="sd">                         &quot;&#39;m&quot;,</span>
<span class="sd">                         &#39;sure&#39;,</span>
<span class="sd">                         &#39;we&#39;,</span>
<span class="sd">                         &#39;could&#39;,</span>
<span class="sd">                         &#39;find&#39;,</span>
<span class="sd">                         &#39;you&#39;,</span>
<span class="sd">                         &#39;suitable&#39;,</span>
<span class="sd">                         &#39;accommodations&#39;,</span>
<span class="sd">                         &#39;.&#39;]}]</span>

<span class="sd">            Output:</span>

<span class="sd">            [[my army will find you boat],</span>
<span class="sd">             [i be sure, we could find you suitable accommodation]]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">output_format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Eventuality&quot;</span><span class="p">,</span> <span class="s2">&quot;json&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Error: extract_eventualities_from_parsed_result only supports Eventuality or json.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eventuality_extractor</span><span class="o">.</span><span class="n">extract_from_parsed_result</span><span class="p">(</span>
            <span class="n">parsed_result</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="n">output_format</span><span class="p">,</span> <span class="n">in_order</span><span class="o">=</span><span class="n">in_order</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="BaseASERExtractor.extract_eventualities_from_text"><a class="viewcode-back" href="../../../api/extractor.html#aser.extract.aser_extractor.BaseASERExtractor.extract_eventualities_from_text">[docs]</a>    <span class="k">def</span> <span class="nf">extract_eventualities_from_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="s2">&quot;Eventuality&quot;</span><span class="p">,</span> <span class="n">in_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">annotators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Extract eventualities from a raw text</span>

<span class="sd">        :param text: a raw text</span>
<span class="sd">        :type text: str</span>
<span class="sd">        :param output_format: which format to return, &quot;Eventuality&quot; or &quot;json&quot;</span>
<span class="sd">        :type output_format: str (default = &quot;Eventuality&quot;)</span>
<span class="sd">        :param in_order: whether the returned order follows the input token order</span>
<span class="sd">        :type in_order: bool (default = True)</span>
<span class="sd">        :param annotators: annotators for corenlp, please refer to https://stanfordnlp.github.io/CoreNLP/annotators.html</span>
<span class="sd">        :type annotators: Union[List, None] (default = None)</span>
<span class="sd">        :param kw: other parameters</span>
<span class="sd">        :type kw: Dict[str, object]</span>
<span class="sd">        :return: the extracted eventualities</span>
<span class="sd">        :rtype: Union[List[List[aser.eventuality.Eventuality]], List[List[Dict[str, object]]], List[aser.eventuality.Eventuality], List[Dict[str, object]]]</span>

<span class="sd">        .. highlight:: python</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            Input:</span>

<span class="sd">            &quot;My army will find your boat. In the meantime, I&#39;m sure we could find you suitable accommodations.&quot;</span>

<span class="sd">            Output:</span>

<span class="sd">            [[my army will find you boat],</span>
<span class="sd">             [i be sure, we could find you suitable accommodation]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">output_format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Eventuality&quot;</span><span class="p">,</span> <span class="s2">&quot;json&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Error: extract_eventualities_from_text only supports Eventuality or json.&quot;</span><span class="p">)</span>

        <span class="n">parsed_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">annotators</span><span class="o">=</span><span class="n">annotators</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_eventualities_from_parsed_result</span><span class="p">(</span>
            <span class="n">parsed_result</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="n">output_format</span><span class="p">,</span> <span class="n">in_order</span><span class="o">=</span><span class="n">in_order</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="BaseASERExtractor.extract_relations_from_parsed_result"><a class="viewcode-back" href="../../../api/extractor.html#aser.extract.aser_extractor.BaseASERExtractor.extract_relations_from_parsed_result">[docs]</a>    <span class="k">def</span> <span class="nf">extract_relations_from_parsed_result</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">parsed_result</span><span class="p">,</span> <span class="n">para_eventualities</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="s2">&quot;Relation&quot;</span><span class="p">,</span> <span class="n">in_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Extract relations from a parsed result (of a paragraph) and extracted eventualities</span>

<span class="sd">        :param parsed_result: the parsed result returned by corenlp</span>
<span class="sd">        :type parsed_result: List[Dict[str, object]]</span>
<span class="sd">        :param para_eventualities: eventualities in the paragraph</span>
<span class="sd">        :type para_eventualities: List[aser.eventuality.Eventuality]</span>
<span class="sd">        :param output_format: which format to return, &quot;Relation&quot; or &quot;triplet&quot;</span>
<span class="sd">        :type output_format: str (default = &quot;Relation&quot;)</span>
<span class="sd">        :param in_order: whether the returned order follows the input token order</span>
<span class="sd">        :type in_order: bool (default = True)</span>
<span class="sd">        :param kw: other parameters</span>
<span class="sd">        :type kw: Dict[str, object]</span>
<span class="sd">        :return: the extracted relations</span>
<span class="sd">        :rtype: Union[List[List[aser.relation.Relation]], List[List[Dict[str, object]]], List[aser.relation.Relation], List[Dict[str, object]]]</span>

<span class="sd">        .. highlight:: python</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            Input:</span>

<span class="sd">                [{&#39;dependencies&#39;: [(1, &#39;nmod:poss&#39;, 0),</span>
<span class="sd">                                   (3, &#39;nsubj&#39;, 1),</span>
<span class="sd">                                   (3, &#39;aux&#39;, 2),</span>
<span class="sd">                                   (3, &#39;dobj&#39;, 5),</span>
<span class="sd">                                   (3, &#39;punct&#39;, 6),</span>
<span class="sd">                                   (5, &#39;nmod:poss&#39;, 4)],</span>
<span class="sd">                  &#39;lemmas&#39;: [&#39;my&#39;, &#39;army&#39;, &#39;will&#39;, &#39;find&#39;, &#39;you&#39;, &#39;boat&#39;, &#39;.&#39;],</span>
<span class="sd">                  &#39;mentions&#39;: [],</span>
<span class="sd">                  &#39;ners&#39;: [&#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;],</span>
<span class="sd">                  &#39;parse&#39;: &#39;(ROOT (S (NP (PRP$ My) (NN army)) (VP (MD will) (VP (VB find) (NP &#39;</span>
<span class="sd">                           &#39;(PRP$ your) (NN boat)))) (. .)))&#39;,</span>
<span class="sd">                  &#39;pos_tags&#39;: [&#39;PRP$&#39;, &#39;NN&#39;, &#39;MD&#39;, &#39;VB&#39;, &#39;PRP$&#39;, &#39;NN&#39;, &#39;.&#39;],</span>
<span class="sd">                  &#39;text&#39;: &#39;My army will find your boat.&#39;,</span>
<span class="sd">                  &#39;tokens&#39;: [&#39;My&#39;, &#39;army&#39;, &#39;will&#39;, &#39;find&#39;, &#39;your&#39;, &#39;boat&#39;, &#39;.&#39;]},</span>
<span class="sd">                 {&#39;dependencies&#39;: [(2, &#39;case&#39;, 0),</span>
<span class="sd">                                   (2, &#39;det&#39;, 1),</span>
<span class="sd">                                   (6, &#39;nmod:in&#39;, 2),</span>
<span class="sd">                                   (6, &#39;punct&#39;, 3),</span>
<span class="sd">                                   (6, &#39;nsubj&#39;, 4),</span>
<span class="sd">                                   (6, &#39;cop&#39;, 5),</span>
<span class="sd">                                   (6, &#39;ccomp&#39;, 9),</span>
<span class="sd">                                   (6, &#39;punct&#39;, 13),</span>
<span class="sd">                                   (9, &#39;nsubj&#39;, 7),</span>
<span class="sd">                                   (9, &#39;aux&#39;, 8),</span>
<span class="sd">                                   (9, &#39;iobj&#39;, 10),</span>
<span class="sd">                                   (9, &#39;dobj&#39;, 12),</span>
<span class="sd">                                   (12, &#39;amod&#39;, 11)],</span>
<span class="sd">                  &#39;lemmas&#39;: [&#39;in&#39;,</span>
<span class="sd">                             &#39;the&#39;,</span>
<span class="sd">                             &#39;meantime&#39;,</span>
<span class="sd">                             &#39;,&#39;,</span>
<span class="sd">                             &#39;I&#39;,</span>
<span class="sd">                             &#39;be&#39;,</span>
<span class="sd">                             &#39;sure&#39;,</span>
<span class="sd">                             &#39;we&#39;,</span>
<span class="sd">                             &#39;could&#39;,</span>
<span class="sd">                             &#39;find&#39;,</span>
<span class="sd">                             &#39;you&#39;,</span>
<span class="sd">                             &#39;suitable&#39;,</span>
<span class="sd">                             &#39;accommodation&#39;,</span>
<span class="sd">                             &#39;.&#39;],</span>
<span class="sd">                  &#39;mentions&#39;: [],</span>
<span class="sd">                  &#39;ners&#39;: [&#39;O&#39;,</span>
<span class="sd">                           &#39;O&#39;,</span>
<span class="sd">                           &#39;O&#39;,</span>
<span class="sd">                           &#39;O&#39;,</span>
<span class="sd">                           &#39;O&#39;,</span>
<span class="sd">                           &#39;O&#39;,</span>
<span class="sd">                           &#39;O&#39;,</span>
<span class="sd">                           &#39;O&#39;,</span>
<span class="sd">                           &#39;O&#39;,</span>
<span class="sd">                           &#39;O&#39;,</span>
<span class="sd">                           &#39;O&#39;,</span>
<span class="sd">                           &#39;O&#39;,</span>
<span class="sd">                           &#39;O&#39;,</span>
<span class="sd">                           &#39;O&#39;],</span>
<span class="sd">                  &#39;parse&#39;: &#39;(ROOT (S (PP (IN In) (NP (DT the) (NN meantime))) (, ,) (NP (PRP &#39;</span>
<span class="sd">                           &quot;I)) (VP (VBP &#39;m) (ADJP (JJ sure) (SBAR (S (NP (PRP we)) (VP (MD &quot;</span>
<span class="sd">                           &#39;could) (VP (VB find) (NP (PRP you)) (NP (JJ suitable) (NNS &#39;</span>
<span class="sd">                           &#39;accommodations)))))))) (. .)))&#39;,</span>
<span class="sd">                  &#39;pos_tags&#39;: [&#39;IN&#39;,</span>
<span class="sd">                               &#39;DT&#39;,</span>
<span class="sd">                               &#39;NN&#39;,</span>
<span class="sd">                               &#39;,&#39;,</span>
<span class="sd">                               &#39;PRP&#39;,</span>
<span class="sd">                               &#39;VBP&#39;,</span>
<span class="sd">                               &#39;JJ&#39;,</span>
<span class="sd">                               &#39;PRP&#39;,</span>
<span class="sd">                               &#39;MD&#39;,</span>
<span class="sd">                               &#39;VB&#39;,</span>
<span class="sd">                               &#39;PRP&#39;,</span>
<span class="sd">                               &#39;JJ&#39;,</span>
<span class="sd">                               &#39;NNS&#39;,</span>
<span class="sd">                               &#39;.&#39;],</span>
<span class="sd">                  &#39;text&#39;: &quot;In the meantime, I&#39;m sure we could find you suitable &quot;</span>
<span class="sd">                          &#39;accommodations.&#39;,</span>
<span class="sd">                  &#39;tokens&#39;: [&#39;In&#39;,</span>
<span class="sd">                             &#39;the&#39;,</span>
<span class="sd">                             &#39;meantime&#39;,</span>
<span class="sd">                             &#39;,&#39;,</span>
<span class="sd">                             &#39;I&#39;,</span>
<span class="sd">                             &quot;&#39;m&quot;,</span>
<span class="sd">                             &#39;sure&#39;,</span>
<span class="sd">                             &#39;we&#39;,</span>
<span class="sd">                             &#39;could&#39;,</span>
<span class="sd">                             &#39;find&#39;,</span>
<span class="sd">                             &#39;you&#39;,</span>
<span class="sd">                             &#39;suitable&#39;,</span>
<span class="sd">                             &#39;accommodations&#39;,</span>
<span class="sd">                             &#39;.&#39;]}],</span>
<span class="sd">                [[my army will find you boat],</span>
<span class="sd">                 [i be sure, we could find you suitable accommodation]]</span>

<span class="sd">                Output:</span>

<span class="sd">                [[],</span>
<span class="sd">                 [(7d9ea9023b66a0ebc167f0dbb6ea8cd75d7b46f9, 25edad6781577dcb3ba715c8230416fb0d4c45c4, {&#39;Co_Occurrence&#39;: 1.0})],</span>
<span class="sd">                 [(8540897b645962964fd644242d4cc0032f024e86, 25edad6781577dcb3ba715c8230416fb0d4c45c4, {&#39;Synchronous&#39;: 1.0})]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">output_format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Relation&quot;</span><span class="p">,</span> <span class="s2">&quot;triplet&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Error: extract_relations_from_parsed_result only supports Relation or triplet.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">relation_extractor</span><span class="o">.</span><span class="n">extract_from_parsed_result</span><span class="p">(</span>
            <span class="n">parsed_result</span><span class="p">,</span> <span class="n">para_eventualities</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="n">output_format</span><span class="p">,</span> <span class="n">in_order</span><span class="o">=</span><span class="n">in_order</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="BaseASERExtractor.extract_relations_from_text"><a class="viewcode-back" href="../../../api/extractor.html#aser.extract.aser_extractor.BaseASERExtractor.extract_relations_from_text">[docs]</a>    <span class="k">def</span> <span class="nf">extract_relations_from_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="s2">&quot;Relation&quot;</span><span class="p">,</span> <span class="n">in_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">annotators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Extract relations from a raw text and extracted eventualities</span>

<span class="sd">        :param text: a raw text</span>
<span class="sd">        :type text: str</span>
<span class="sd">        :param output_format: which format to return, &quot;Relation&quot; or &quot;triplet&quot;</span>
<span class="sd">        :type output_format: str (default = &quot;Relation&quot;)</span>
<span class="sd">        :param in_order: whether the returned order follows the input token order</span>
<span class="sd">        :type in_order: bool (default = True)</span>
<span class="sd">        :param annotators: annotators for corenlp, please refer to https://stanfordnlp.github.io/CoreNLP/annotators.html</span>
<span class="sd">        :type annotators: Union[List, None] (default = None)</span>
<span class="sd">        :param kw: other parameters</span>
<span class="sd">        :type kw: Dict[str, object]</span>
<span class="sd">        :return: the extracted relations</span>
<span class="sd">        :rtype: Union[List[List[aser.relation.Relation]], List[List[Dict[str, object]]], List[aser.relation.Relation], List[Dict[str, object]]]</span>

<span class="sd">        .. highlight:: python</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            Input:</span>

<span class="sd">            &quot;My army will find your boat. In the meantime, I&#39;m sure we could find you suitable accommodations.&quot;</span>

<span class="sd">            Output:</span>

<span class="sd">            [[],</span>
<span class="sd">             [(7d9ea9023b66a0ebc167f0dbb6ea8cd75d7b46f9, 25edad6781577dcb3ba715c8230416fb0d4c45c4, {&#39;Co_Occurrence&#39;: 1.0})],</span>
<span class="sd">             [(8540897b645962964fd644242d4cc0032f024e86, 25edad6781577dcb3ba715c8230416fb0d4c45c4, {&#39;Synchronous&#39;: 1.0})]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">output_format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Relation&quot;</span><span class="p">,</span> <span class="s2">&quot;triplet&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Error: extract_relations_from_text only supports Relation or triplet.&quot;</span><span class="p">)</span>

        <span class="n">parsed_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">annotators</span><span class="o">=</span><span class="n">annotators</span><span class="p">)</span>
        <span class="n">para_eventualities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_eventualities_from_parsed_result</span><span class="p">(</span><span class="n">parsed_result</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_relations_from_parsed_result</span><span class="p">(</span>
            <span class="n">parsed_result</span><span class="p">,</span> <span class="n">para_eventualities</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="n">output_format</span><span class="p">,</span> <span class="n">in_order</span><span class="o">=</span><span class="n">in_order</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="BaseASERExtractor.extract_from_parsed_result"><a class="viewcode-back" href="../../../api/extractor.html#aser.extract.aser_extractor.BaseASERExtractor.extract_from_parsed_result">[docs]</a>    <span class="k">def</span> <span class="nf">extract_from_parsed_result</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">parsed_result</span><span class="p">,</span>
        <span class="n">eventuality_output_format</span><span class="o">=</span><span class="s2">&quot;Eventuality&quot;</span><span class="p">,</span>
        <span class="n">relation_output_format</span><span class="o">=</span><span class="s2">&quot;Relation&quot;</span><span class="p">,</span>
        <span class="n">in_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Extract both eventualities and relations from a parsed result</span>

<span class="sd">        :param parsed_result: the parsed result returned by corenlp</span>
<span class="sd">        :type parsed_result: List[Dict[str, object]]</span>
<span class="sd">        :param eventuality_output_format: which format to return eventualities, &quot;Eventuality&quot; or &quot;json&quot;</span>
<span class="sd">        :type eventuality_output_format: str (default = &quot;Eventuality&quot;)</span>
<span class="sd">        :param relation_output_format: which format to return relations, &quot;Relation&quot; or &quot;triplet&quot;</span>
<span class="sd">        :type relation_output_format: str (default = &quot;Relation&quot;)</span>
<span class="sd">        :param in_order: whether the returned order follows the input token order</span>
<span class="sd">        :type in_order: bool (default = True)</span>
<span class="sd">        :param kw: other parameters</span>
<span class="sd">        :type kw: Dict[str, object]</span>
<span class="sd">        :return: the extracted eventualities and relations</span>
<span class="sd">        :rtype: Tuple[Union[List[List[aser.eventuality.Eventuality]], List[List[Dict[str, object]]], List[aser.eventuality.Eventuality], List[Dict[str, object]]], Union[List[List[aser.relation.Relation]], List[List[Dict[str, object]]], List[aser.relation.Relation], List[Dict[str, object]]]]</span>

<span class="sd">        .. highlight:: python</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            Input:</span>

<span class="sd">            [{&#39;dependencies&#39;: [(1, &#39;nmod:poss&#39;, 0),</span>
<span class="sd">                               (3, &#39;nsubj&#39;, 1),</span>
<span class="sd">                               (3, &#39;aux&#39;, 2),</span>
<span class="sd">                               (3, &#39;dobj&#39;, 5),</span>
<span class="sd">                               (3, &#39;punct&#39;, 6),</span>
<span class="sd">                               (5, &#39;nmod:poss&#39;, 4)],</span>
<span class="sd">              &#39;lemmas&#39;: [&#39;my&#39;, &#39;army&#39;, &#39;will&#39;, &#39;find&#39;, &#39;you&#39;, &#39;boat&#39;, &#39;.&#39;],</span>
<span class="sd">              &#39;mentions&#39;: [],</span>
<span class="sd">              &#39;ners&#39;: [&#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;, &#39;O&#39;],</span>
<span class="sd">              &#39;parse&#39;: &#39;(ROOT (S (NP (PRP$ My) (NN army)) (VP (MD will) (VP (VB find) (NP &#39;</span>
<span class="sd">                       &#39;(PRP$ your) (NN boat)))) (. .)))&#39;,</span>
<span class="sd">              &#39;pos_tags&#39;: [&#39;PRP$&#39;, &#39;NN&#39;, &#39;MD&#39;, &#39;VB&#39;, &#39;PRP$&#39;, &#39;NN&#39;, &#39;.&#39;],</span>
<span class="sd">              &#39;text&#39;: &#39;My army will find your boat.&#39;,</span>
<span class="sd">              &#39;tokens&#39;: [&#39;My&#39;, &#39;army&#39;, &#39;will&#39;, &#39;find&#39;, &#39;your&#39;, &#39;boat&#39;, &#39;.&#39;]},</span>
<span class="sd">             {&#39;dependencies&#39;: [(2, &#39;case&#39;, 0),</span>
<span class="sd">                               (2, &#39;det&#39;, 1),</span>
<span class="sd">                               (6, &#39;nmod:in&#39;, 2),</span>
<span class="sd">                               (6, &#39;punct&#39;, 3),</span>
<span class="sd">                               (6, &#39;nsubj&#39;, 4),</span>
<span class="sd">                               (6, &#39;cop&#39;, 5),</span>
<span class="sd">                               (6, &#39;ccomp&#39;, 9),</span>
<span class="sd">                               (6, &#39;punct&#39;, 13),</span>
<span class="sd">                               (9, &#39;nsubj&#39;, 7),</span>
<span class="sd">                               (9, &#39;aux&#39;, 8),</span>
<span class="sd">                               (9, &#39;iobj&#39;, 10),</span>
<span class="sd">                               (9, &#39;dobj&#39;, 12),</span>
<span class="sd">                               (12, &#39;amod&#39;, 11)],</span>
<span class="sd">              &#39;lemmas&#39;: [&#39;in&#39;,</span>
<span class="sd">                         &#39;the&#39;,</span>
<span class="sd">                         &#39;meantime&#39;,</span>
<span class="sd">                         &#39;,&#39;,</span>
<span class="sd">                         &#39;I&#39;,</span>
<span class="sd">                         &#39;be&#39;,</span>
<span class="sd">                         &#39;sure&#39;,</span>
<span class="sd">                         &#39;we&#39;,</span>
<span class="sd">                         &#39;could&#39;,</span>
<span class="sd">                         &#39;find&#39;,</span>
<span class="sd">                         &#39;you&#39;,</span>
<span class="sd">                         &#39;suitable&#39;,</span>
<span class="sd">                         &#39;accommodation&#39;,</span>
<span class="sd">                         &#39;.&#39;],</span>
<span class="sd">              &#39;mentions&#39;: [],</span>
<span class="sd">              &#39;ners&#39;: [&#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;,</span>
<span class="sd">                       &#39;O&#39;],</span>
<span class="sd">              &#39;parse&#39;: &#39;(ROOT (S (PP (IN In) (NP (DT the) (NN meantime))) (, ,) (NP (PRP &#39;</span>
<span class="sd">                       &quot;I)) (VP (VBP &#39;m) (ADJP (JJ sure) (SBAR (S (NP (PRP we)) (VP (MD &quot;</span>
<span class="sd">                       &#39;could) (VP (VB find) (NP (PRP you)) (NP (JJ suitable) (NNS &#39;</span>
<span class="sd">                       &#39;accommodations)))))))) (. .)))&#39;,</span>
<span class="sd">              &#39;pos_tags&#39;: [&#39;IN&#39;,</span>
<span class="sd">                           &#39;DT&#39;,</span>
<span class="sd">                           &#39;NN&#39;,</span>
<span class="sd">                           &#39;,&#39;,</span>
<span class="sd">                           &#39;PRP&#39;,</span>
<span class="sd">                           &#39;VBP&#39;,</span>
<span class="sd">                           &#39;JJ&#39;,</span>
<span class="sd">                           &#39;PRP&#39;,</span>
<span class="sd">                           &#39;MD&#39;,</span>
<span class="sd">                           &#39;VB&#39;,</span>
<span class="sd">                           &#39;PRP&#39;,</span>
<span class="sd">                           &#39;JJ&#39;,</span>
<span class="sd">                           &#39;NNS&#39;,</span>
<span class="sd">                           &#39;.&#39;],</span>
<span class="sd">              &#39;text&#39;: &quot;In the meantime, I&#39;m sure we could find you suitable &quot;</span>
<span class="sd">                      &#39;accommodations.&#39;,</span>
<span class="sd">              &#39;tokens&#39;: [&#39;In&#39;,</span>
<span class="sd">                         &#39;the&#39;,</span>
<span class="sd">                         &#39;meantime&#39;,</span>
<span class="sd">                         &#39;,&#39;,</span>
<span class="sd">                         &#39;I&#39;,</span>
<span class="sd">                         &quot;&#39;m&quot;,</span>
<span class="sd">                         &#39;sure&#39;,</span>
<span class="sd">                         &#39;we&#39;,</span>
<span class="sd">                         &#39;could&#39;,</span>
<span class="sd">                         &#39;find&#39;,</span>
<span class="sd">                         &#39;you&#39;,</span>
<span class="sd">                         &#39;suitable&#39;,</span>
<span class="sd">                         &#39;accommodations&#39;,</span>
<span class="sd">                         &#39;.&#39;]}],</span>
<span class="sd">            [[my army will find you boat],</span>
<span class="sd">             [i be sure, we could find you suitable accommodation]]</span>

<span class="sd">            Output:</span>

<span class="sd">            ([[my army will find you boat],</span>
<span class="sd">              [i be sure, we could find you suitable accommodation]],</span>
<span class="sd">             [[],</span>
<span class="sd">              [(7d9ea9023b66a0ebc167f0dbb6ea8cd75d7b46f9, 25edad6781577dcb3ba715c8230416fb0d4c45c4, {&#39;Co_Occurrence&#39;: 1.0})],</span>
<span class="sd">              [(8540897b645962964fd644242d4cc0032f024e86, 25edad6781577dcb3ba715c8230416fb0d4c45c4, {&#39;Synchronous&#39;: 1.0})]])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">eventuality_output_format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Eventuality&quot;</span><span class="p">,</span> <span class="s2">&quot;json&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Error: extract_eventualities only supports Eventuality or json.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">relation_output_format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Relation&quot;</span><span class="p">,</span> <span class="s2">&quot;triplet&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Error: extract_relations only supports Relation or triplet.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parsed_result</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parsed_result</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">is_single_sent</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">parsed_result</span> <span class="o">=</span> <span class="p">[</span><span class="n">parsed_result</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_single_sent</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">para_eventualities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_eventualities_from_parsed_result</span><span class="p">(</span>
            <span class="n">parsed_result</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="s2">&quot;Eventuality&quot;</span><span class="p">,</span> <span class="n">in_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span>
        <span class="p">)</span>
        <span class="n">para_relations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_relations_from_parsed_result</span><span class="p">(</span>
            <span class="n">parsed_result</span><span class="p">,</span> <span class="n">para_eventualities</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="s2">&quot;Relation&quot;</span><span class="p">,</span> <span class="n">in_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">in_order</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">eventuality_output_format</span> <span class="o">==</span> <span class="s2">&quot;json&quot;</span><span class="p">:</span>
                <span class="n">para_eventualities</span> <span class="o">=</span> <span class="p">[[</span><span class="n">eventuality</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">eventuality</span> <span class="ow">in</span> <span class="n">sent_eventualities</span><span class="p">]</span> \
                                      <span class="k">for</span> <span class="n">sent_eventualities</span> <span class="ow">in</span> <span class="n">para_eventualities</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">relation_output_format</span> <span class="o">==</span> <span class="s2">&quot;triplet&quot;</span><span class="p">:</span>
                <span class="n">para_relations</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">([</span><span class="n">relation</span><span class="o">.</span><span class="n">to_triplet</span><span class="p">()</span> <span class="k">for</span> <span class="n">relation</span> <span class="ow">in</span> <span class="n">sent_relations</span><span class="p">]))</span> \
                             <span class="k">for</span> <span class="n">sent_relations</span> <span class="ow">in</span> <span class="n">para_relations</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">is_single_sent</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">para_eventualities</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">para_relations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">para_eventualities</span><span class="p">,</span> <span class="n">para_relations</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eid2eventuality</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">eventuality</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">para_eventualities</span><span class="p">):</span>
                <span class="n">eid</span> <span class="o">=</span> <span class="n">eventuality</span><span class="o">.</span><span class="n">eid</span>
                <span class="k">if</span> <span class="n">eid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">eid2eventuality</span><span class="p">:</span>
                    <span class="n">eid2eventuality</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">eventuality</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">eid2eventuality</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">eventuality</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">eventuality_output_format</span> <span class="o">==</span> <span class="s2">&quot;Eventuality&quot;</span><span class="p">:</span>
                <span class="n">eventualities</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">eid2eventuality</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">eid</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">eventuality_output_format</span> <span class="o">==</span> <span class="s2">&quot;json&quot;</span><span class="p">:</span>
                <span class="n">eventualities</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">eventuality</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">eventuality</span> <span class="ow">in</span> <span class="n">eid2eventuality</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;eid&quot;</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="n">rid2relation</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">relation</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">para_relations</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">relation</span><span class="o">.</span><span class="n">rid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rid2relation</span><span class="p">:</span>
                    <span class="n">rid2relation</span><span class="p">[</span><span class="n">relation</span><span class="o">.</span><span class="n">rid</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">relation</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rid2relation</span><span class="p">[</span><span class="n">relation</span><span class="o">.</span><span class="n">rid</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">relation</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">relation_output_format</span> <span class="o">==</span> <span class="s2">&quot;Relation&quot;</span><span class="p">:</span>
                <span class="n">para_relations</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">rid2relation</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span><span class="o">.</span><span class="n">rid</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">relation_output_format</span> <span class="o">==</span> <span class="s2">&quot;triplet&quot;</span><span class="p">:</span>
                <span class="n">para_relations</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">([</span><span class="n">relation</span><span class="o">.</span><span class="n">to_triplets</span><span class="p">()</span> <span class="k">for</span> <span class="n">relation</span> <span class="ow">in</span> <span class="n">rid2relation</span><span class="o">.</span><span class="n">values</span><span class="p">()]))</span>
            <span class="k">return</span> <span class="n">eventualities</span><span class="p">,</span> <span class="n">para_relations</span></div>

<div class="viewcode-block" id="BaseASERExtractor.extract_from_text"><a class="viewcode-back" href="../../../api/extractor.html#aser.extract.aser_extractor.BaseASERExtractor.extract_from_text">[docs]</a>    <span class="k">def</span> <span class="nf">extract_from_text</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">text</span><span class="p">,</span>
        <span class="n">eventuality_output_format</span><span class="o">=</span><span class="s2">&quot;Eventuality&quot;</span><span class="p">,</span>
        <span class="n">relation_output_format</span><span class="o">=</span><span class="s2">&quot;Relation&quot;</span><span class="p">,</span>
        <span class="n">in_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">annotators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Extract both eventualities and relations from a raw text</span>

<span class="sd">        :param text: a raw text</span>
<span class="sd">        :type text: str</span>
<span class="sd">        :param eventuality_output_format: which format to return eventualities, &quot;Eventuality&quot; or &quot;json&quot;</span>
<span class="sd">        :type eventuality_output_format: str (default = &quot;Eventuality&quot;)</span>
<span class="sd">        :param relation_output_format: which format to return relations, &quot;Relation&quot; or &quot;triplet&quot;</span>
<span class="sd">        :type relation_output_format: str (default = &quot;Relation&quot;)</span>
<span class="sd">        :param in_order: whether the returned order follows the input token order</span>
<span class="sd">        :type in_order: bool (default = True)</span>
<span class="sd">        :param annotators: annotators for corenlp, please refer to https://stanfordnlp.github.io/CoreNLP/annotators.html</span>
<span class="sd">        :type annotators: Union[List, None] (default = None)</span>
<span class="sd">        :param kw: other parameters</span>
<span class="sd">        :type kw: Dict[str, object]</span>
<span class="sd">        :return: the extracted eventualities and relations</span>
<span class="sd">        :rtype: :rtype: Tuple[Union[List[List[aser.eventuality.Eventuality]], List[List[Dict[str, object]]], List[aser.eventuality.Eventuality], List[Dict[str, object]]], Union[List[List[aser.relation.Relation]], List[List[Dict[str, object]]], List[aser.relation.Relation], List[Dict[str, object]]]]</span>

<span class="sd">        .. highlight:: python</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            Input:</span>

<span class="sd">            &quot;My army will find your boat. In the meantime, I&#39;m sure we could find you suitable accommodations.&quot;</span>

<span class="sd">            Output:</span>

<span class="sd">            ([[my army will find you boat],</span>
<span class="sd">              [i be sure, we could find you suitable accommodation]],</span>
<span class="sd">             [[],</span>
<span class="sd">              [(7d9ea9023b66a0ebc167f0dbb6ea8cd75d7b46f9, 25edad6781577dcb3ba715c8230416fb0d4c45c4, {&#39;Co_Occurrence&#39;: 1.0})],</span>
<span class="sd">              [(8540897b645962964fd644242d4cc0032f024e86, 25edad6781577dcb3ba715c8230416fb0d4c45c4, {&#39;Synchronous&#39;: 1.0})]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">eventuality_output_format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Eventuality&quot;</span><span class="p">,</span> <span class="s2">&quot;json&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Error: extract_eventualities only supports Eventuality or json.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">relation_output_format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Relation&quot;</span><span class="p">,</span> <span class="s2">&quot;triplet&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Error: extract_relations only supports Relation or triplet.&quot;</span><span class="p">)</span>

        <span class="n">parsed_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">annotators</span><span class="o">=</span><span class="n">annotators</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_from_parsed_result</span><span class="p">(</span>
            <span class="n">parsed_result</span><span class="p">,</span>
            <span class="n">eventuality_output_format</span><span class="o">=</span><span class="n">eventuality_output_format</span><span class="p">,</span>
            <span class="n">relation_output_format</span><span class="o">=</span><span class="n">relation_output_format</span><span class="p">,</span>
            <span class="n">in_order</span><span class="o">=</span><span class="n">in_order</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kw</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="SeedRuleASERExtractor"><a class="viewcode-back" href="../../../api/extractor.html#aser.extract.aser_extractor.SeedRuleASERExtractor">[docs]</a><span class="k">class</span> <span class="nc">SeedRuleASERExtractor</span><span class="p">(</span><span class="n">BaseASERExtractor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; ASER Extractor based on rules to extract both eventualities and relations (for ASER v1.0)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corenlp_path</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">corenlp_port</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;annotators&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;annotators&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ANNOTATORS</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;parse&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;annotators&quot;</span><span class="p">]:</span>
                <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;annotators&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;parse&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;depparse&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;annotators&quot;</span><span class="p">]:</span>
                <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;annotator&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;depparse&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">corenlp_path</span><span class="p">,</span> <span class="n">corenlp_port</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="kn">from</span> <span class="nn">aser.extract.rule</span> <span class="kn">import</span> <span class="n">CLAUSE_WORDS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eventuality_extractor</span> <span class="o">=</span> <span class="n">SeedRuleEventualityExtractor</span><span class="p">(</span>
            <span class="n">corenlp_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corenlp_path</span><span class="p">,</span> <span class="n">corenlp_port</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corenlp_port</span><span class="p">,</span> <span class="n">skip_words</span><span class="o">=</span><span class="n">CLAUSE_WORDS</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relation_extractor</span> <span class="o">=</span> <span class="n">SeedRuleRelationExtractor</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span></div>


<div class="viewcode-block" id="DiscourseASERExtractor"><a class="viewcode-back" href="../../../api/extractor.html#aser.extract.aser_extractor.DiscourseASERExtractor">[docs]</a><span class="k">class</span> <span class="nc">DiscourseASERExtractor</span><span class="p">(</span><span class="n">BaseASERExtractor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; ASER Extractor based on discourse parsing to extract both eventualities and relations (for ASER v2.0)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corenlp_path</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">corenlp_port</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;annotators&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;annotators&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ANNOTATORS</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;depparse&quot;</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;annotators&quot;</span><span class="p">]:</span>
                <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;annotator&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;depparse&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;parse&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;annotators&quot;</span><span class="p">]:</span>
                <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;annotators&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;parse&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">corenlp_path</span><span class="p">,</span> <span class="n">corenlp_port</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eventuality_extractor</span> <span class="o">=</span> <span class="n">DiscourseEventualityExtractor</span><span class="p">(</span>
            <span class="n">corenlp_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corenlp_path</span><span class="p">,</span> <span class="n">corenlp_port</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">corenlp_port</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relation_extractor</span> <span class="o">=</span> <span class="n">DiscourseRelationExtractor</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>

<div class="viewcode-block" id="DiscourseASERExtractor.extract_from_parsed_result"><a class="viewcode-back" href="../../../api/extractor.html#aser.extract.aser_extractor.DiscourseASERExtractor.extract_from_parsed_result">[docs]</a>    <span class="k">def</span> <span class="nf">extract_from_parsed_result</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">parsed_result</span><span class="p">,</span>
        <span class="n">eventuality_output_format</span><span class="o">=</span><span class="s2">&quot;Eventuality&quot;</span><span class="p">,</span>
        <span class="n">relation_output_format</span><span class="o">=</span><span class="s2">&quot;Relation&quot;</span><span class="p">,</span>
        <span class="n">in_order</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Extract both eventualities and relations from a parsed result</span>

<span class="sd">        :param parsed_result: the parsed result returned by corenlp</span>
<span class="sd">        :type parsed_result: List[Dict[str, object]]</span>
<span class="sd">        :param eventuality_output_format: which format to return eventualities, &quot;Eventuality&quot; or &quot;json&quot;</span>
<span class="sd">        :type eventuality_output_format: str (default = &quot;Eventuality&quot;)</span>
<span class="sd">        :param relation_output_format: which format to return relations, &quot;Relation&quot; or &quot;triplet&quot;</span>
<span class="sd">        :type relation_output_format: str (default = &quot;Relation&quot;)</span>
<span class="sd">        :param in_order: whether the returned order follows the input token order</span>
<span class="sd">        :type in_order: bool (default = True)</span>
<span class="sd">        :param kw: other parameters (e.g., syntax_tree_cache)</span>
<span class="sd">        :type kw: Dict[str, object]</span>
<span class="sd">        :return: the extracted eventualities and relations</span>
<span class="sd">        :rtype: :rtype: Tuple[Union[List[List[aser.eventuality.Eventuality]], List[List[Dict[str, object]]], List[aser.eventuality.Eventuality], List[Dict[str, object]]], Union[List[List[aser.relation.Relation]], List[List[Dict[str, object]]], List[aser.relation.Relation], List[Dict[str, object]]]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;syntax_tree_cache&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kw</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;syntax_tree_cache&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">extract_from_parsed_result</span><span class="p">(</span>
            <span class="n">parsed_result</span><span class="p">,</span>
            <span class="n">eventuality_output_format</span><span class="o">=</span><span class="n">eventuality_output_format</span><span class="p">,</span>
            <span class="n">relation_output_format</span><span class="o">=</span><span class="n">relation_output_format</span><span class="p">,</span>
            <span class="n">in_order</span><span class="o">=</span><span class="n">in_order</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kw</span>
        <span class="p">)</span></div></div>

<span class="c1"># The following extractor can cover more eventualities but the semantic meaning may be incomplete.</span>
<span class="c1"># class DiscourseASERExtractor(BaseASERExtractor):</span>
<span class="c1">#     def __init__(self, corenlp_path=&quot;&quot;, corenlp_port=0, **kw):</span>
<span class="c1">#         super().__init__(corenlp_path, corenlp_port, **kw)</span>
<span class="c1">#         self.eventuality_extractor = SeedRuleEventualityExtractor(**kw)</span>
<span class="c1">#         self.conn_extractor = ConnectiveExtractor(**kw)</span>
<span class="c1">#         self.argpos_classifier = ArgumentPositionClassifier(**kw)</span>
<span class="c1">#         self.ss_extractor = SSArgumentExtractor(**kw)</span>
<span class="c1">#         self.ps_extractor = PSArgumentExtractor(**kw)</span>
<span class="c1">#         self.explicit_classifier = ExplicitSenseClassifier(**kw)</span>

<span class="c1">#     def _extract_eventualities_from_clause(self, sent_parsed_result, clause):</span>
<span class="c1">#         len_clause = len(clause)</span>
<span class="c1">#         idx_mapping = {j: i for i, j in enumerate(clause)}</span>
<span class="c1">#         indices_set = set(clause)</span>
<span class="c1">#         clause_parsed_result = {</span>
<span class="c1">#             &quot;text&quot;: &quot;&quot;,</span>
<span class="c1">#             &quot;dependencies&quot;: [(idx_mapping[dep[0]], dep[1], idx_mapping[dep[2]]) for dep in sent_parsed_result[&quot;dependencies&quot;] \</span>
<span class="c1">#                 if dep[0] in indices_set and dep[2] in indices_set],</span>
<span class="c1">#             &quot;tokens&quot;: [sent_parsed_result[&quot;tokens&quot;][idx] for idx in clause],</span>
<span class="c1">#             &quot;pos_tags&quot;: [sent_parsed_result[&quot;pos_tags&quot;][idx] for idx in clause],</span>
<span class="c1">#             &quot;lemmas&quot;: [sent_parsed_result[&quot;lemmas&quot;][idx] for idx in clause]}</span>
<span class="c1">#         if &quot;ners&quot; in sent_parsed_result:</span>
<span class="c1">#             clause_parsed_result[&quot;ners&quot;] = [sent_parsed_result[&quot;ners&quot;][idx] for idx in clause]</span>
<span class="c1">#         if &quot;mentions&quot; in sent_parsed_result:</span>
<span class="c1">#             clause_parsed_result[&quot;mentions&quot;] = list()</span>
<span class="c1">#             for mention in sent_parsed_result[&quot;mentions&quot;]:</span>
<span class="c1">#                 start_idx = bisect.bisect_left(clause, mention[&quot;start&quot;])</span>
<span class="c1">#                 if not (start_idx &lt; len_clause and clause[start_idx] == mention[&quot;start&quot;]):</span>
<span class="c1">#                     continue</span>
<span class="c1">#                 end_idx = bisect.bisect_left(clause, mention[&quot;end&quot;]-1)</span>
<span class="c1">#                 if not (end_idx &lt; len_clause and clause[end_idx] == mention[&quot;end&quot;]-1):</span>
<span class="c1">#                     continue</span>
<span class="c1">#                 mention = copy(mention)</span>
<span class="c1">#                 mention[&quot;start&quot;] = start_idx</span>
<span class="c1">#                 mention[&quot;end&quot;] = end_idx+1</span>
<span class="c1">#                 clause_parsed_result[&quot;mentions&quot;].append(mention)</span>
<span class="c1">#         eventualities = self.eventuality_extractor.extract_from_parsed_result(</span>
<span class="c1">#             clause_parsed_result, output_format=&quot;Eventuality&quot;, in_order=True)</span>
<span class="c1">#         for eventuality in eventualities:</span>
<span class="c1">#             for k, v in eventuality.raw_sent_mapping.items():</span>
<span class="c1">#                 eventuality.raw_sent_mapping[k] = clause[v]</span>
<span class="c1">#             eventuality.eid = Eventuality.generate_eid(eventuality)</span>
<span class="c1">#         return eventualities</span>

<span class="c1">#     def _append_new_eventuaities_to_list(self, existed_eventualities, new_eventualities):</span>
<span class="c1">#         len_existed_eventualities = len(existed_eventualities)</span>
<span class="c1">#         for new_e in new_eventualities:</span>
<span class="c1">#             is_existed = False</span>
<span class="c1">#             for old_idx in range(len_existed_eventualities):</span>
<span class="c1">#                 old_e = existed_eventualities[old_idx]</span>
<span class="c1">#                 if old_e.eid == new_e.eid and old_e.raw_sent_mapping == new_e.raw_sent_mapping:</span>
<span class="c1">#                     is_existed = True</span>
<span class="c1">#                     break</span>
<span class="c1">#             if not is_existed:</span>
<span class="c1">#                 existed_eventualities.append(new_e)</span>

<span class="c1">#     def extract_eventualities_from_parsed_result(self, parsed_result,</span>
<span class="c1">#                                                  output_format=&quot;Eventuality&quot;, in_order=True, **kw):</span>
<span class="c1">#         if output_format not in [&quot;Eventuality&quot;, &quot;json&quot;]:</span>
<span class="c1">#             raise NotImplementedError(&quot;Error: extract_from_parsed_result only supports Eventuality or json.&quot;)</span>

<span class="c1">#         if not isinstance(parsed_result, (list, tuple, dict)):</span>
<span class="c1">#             raise NotImplementedError</span>
<span class="c1">#         if isinstance(parsed_result, dict):</span>
<span class="c1">#             is_single_sent = True</span>
<span class="c1">#             parsed_result = [parsed_result]</span>
<span class="c1">#         else:</span>
<span class="c1">#             is_single_sent = False</span>

<span class="c1">#         syntax_tree_cache = kw.get(&quot;syntax_tree_cache&quot;, dict())</span>

<span class="c1">#         para_eventualities = [list() for _ in range(len(parsed_result))]</span>
<span class="c1">#         para_clauses = self._extract_clauses(parsed_result, syntax_tree_cache)</span>
<span class="c1">#         for sent_parsed_result, sent_clauses, sent_eventualities in zip(parsed_result, para_clauses, para_eventualities):</span>
<span class="c1">#             for clause in sent_clauses:</span>
<span class="c1">#                 sent_eventualities.extend(self._extract_eventualities_from_clause(sent_parsed_result, clause))</span>

<span class="c1">#         if in_order:</span>
<span class="c1">#             if output_format == &quot;json&quot;:</span>
<span class="c1">#                 para_eventualities = [[eventuality.encode(encoding=None) for eventuality in sent_eventualities] \</span>
<span class="c1">#                     for sent_eventualities in para_eventualities]</span>
<span class="c1">#             if is_single_sent:</span>
<span class="c1">#                 return para_eventualities[0]</span>
<span class="c1">#             else:</span>
<span class="c1">#                 return para_eventualities</span>
<span class="c1">#         else:</span>
<span class="c1">#             eid2eventuality = dict()</span>
<span class="c1">#             for eventuality in chain.from_iterable(para_eventualities):</span>
<span class="c1">#                 eid = eventuality.eid</span>
<span class="c1">#                 if eid not in eid2eventuality:</span>
<span class="c1">#                     eid2eventuality[eid] = deepcopy(eventuality)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     eid2eventuality[eid].update(eventuality)</span>
<span class="c1">#             if output_format == &quot;Eventuality&quot;:</span>
<span class="c1">#                 eventualities = sorted(eid2eventuality.values(), key=lambda e: e.eid)</span>
<span class="c1">#             elif output_format == &quot;json&quot;:</span>
<span class="c1">#                 eventualities = sorted([eventuality.encode(encoding=None) for eventuality in eid2eventuality.values()], key=lambda e: e[&quot;eid&quot;])</span>
<span class="c1">#             return eventualities</span>

<span class="c1">#     def extract_relations_from_parsed_result(self, parsed_result, para_eventualities,</span>
<span class="c1">#                                              output_format=&quot;Relation&quot;,</span>
<span class="c1">#                                              in_order=True, **kw):</span>
<span class="c1">#         if output_format not in [&quot;Relation&quot;, &quot;triplet&quot;]:</span>
<span class="c1">#             raise NotImplementedError(&quot;Error: extract_relations_from_parsed_result only supports Relation or triplet.&quot;)</span>

<span class="c1">#         len_sentences = len(parsed_result)</span>
<span class="c1">#         if len_sentences == 0:</span>
<span class="c1">#             if in_order:</span>
<span class="c1">#                 return [list()]</span>
<span class="c1">#             else:</span>
<span class="c1">#                 return list()</span>

<span class="c1">#         similarity = kw.get(&quot;similarity&quot;, &quot;simpson&quot;).lower()</span>
<span class="c1">#         threshold = kw.get(&quot;threshold&quot;, 0.8)</span>
<span class="c1">#         if threshold &lt; 0.0 or threshold &gt; 1.0:</span>
<span class="c1">#             raise ValueError(&quot;Error: threshold should be between 0.0 and 1.0.&quot;)</span>
<span class="c1">#         if similarity == &quot;simpson&quot;:</span>
<span class="c1">#             similarity_func = self._match_argument_eventuality_by_Simpson</span>
<span class="c1">#         elif similarity == &quot;jaccard&quot;:</span>
<span class="c1">#             similarity_func = self._match_argument_eventuality_by_Jaccard</span>
<span class="c1">#         elif similarity == &quot;discourse&quot;:</span>
<span class="c1">#             similarity_func = self._match_argument_eventuality_by_dependencies</span>
<span class="c1">#         else:</span>
<span class="c1">#             raise NotImplementedError(&quot;Error: extract_from_parsed_result only supports Simpson or Jaccard.&quot;)</span>

<span class="c1">#         syntax_tree_cache = kw.get(&quot;syntax_tree_cache&quot;, dict())</span>

<span class="c1">#         para_relations = [list() for _ in range(2*len_sentences-1)]</span>

<span class="c1">#         # replace sentences that contains no eventuality with empty sentences</span>
<span class="c1">#         filtered_parsed_result = list()</span>
<span class="c1">#         for sent_idx, (sent_parsed_result, sent_eventualities) in enumerate(zip(parsed_result, para_eventualities)):</span>
<span class="c1">#             if len(sent_eventualities) &gt; 0:</span>
<span class="c1">#                 relations_in_sent = para_relations[sent_idx]</span>
<span class="c1">#                 for e1_idx in range(len(sent_eventualities)-1):</span>
<span class="c1">#                     heid = sent_eventualities[e1_idx].eid</span>
<span class="c1">#                     for e2_idx in range(e1_idx+1, len(sent_eventualities)):</span>
<span class="c1">#                         teid = sent_eventualities[e2_idx].eid</span>
<span class="c1">#                         relations_in_sent.append(Relation(heid, teid, [&quot;Co_Occurrence&quot;]))</span>
<span class="c1">#                 filtered_parsed_result.append(sent_parsed_result)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 filtered_parsed_result.append(EMPTY_SENT_PARSED_RESULT) # empty sentence</span>
<span class="c1">#                 # filtered_parsed_result.append(sent_parsed_result)</span>

<span class="c1">#         connectives = self.conn_extractor.extract(filtered_parsed_result, syntax_tree_cache)</span>
<span class="c1">#         SS_connectives, PS_connectives = self.argpos_classifier.classify(filtered_parsed_result, connectives, syntax_tree_cache)</span>
<span class="c1">#         SS_connectives = self.ss_extractor.extract(filtered_parsed_result, SS_connectives, syntax_tree_cache)</span>
<span class="c1">#         PS_connectives = self.ps_extractor.extract(filtered_parsed_result, PS_connectives, syntax_tree_cache)</span>
<span class="c1">#         connectives = self.explicit_classifier.classify(filtered_parsed_result, SS_connectives+PS_connectives, syntax_tree_cache)</span>
<span class="c1">#         connectives.sort(key=lambda x: (x[&quot;sent_idx&quot;], x[&quot;indices&quot;][0] if len(x[&quot;indices&quot;]) &gt; 0 else -1))</span>

<span class="c1">#         for connective in connectives:</span>
<span class="c1">#             conn_indices = connective.get(&quot;indices&quot;, None)</span>
<span class="c1">#             arg1 = connective.get(&quot;arg1&quot;, None)</span>
<span class="c1">#             arg2 = connective.get(&quot;arg2&quot;, None)</span>
<span class="c1">#             sense = connective.get(&quot;sense&quot;, None)</span>
<span class="c1">#             if conn_indices and arg1 and arg2 and (sense and sense != &quot;None&quot;):</span>
<span class="c1">#                 arg1_sent_idx = arg1[&quot;sent_idx&quot;]</span>
<span class="c1">#                 arg2_sent_idx = arg2[&quot;sent_idx&quot;]</span>
<span class="c1">#                 relation_list_idx = arg1_sent_idx if arg1_sent_idx == arg2_sent_idx else arg1_sent_idx + len_sentences</span>
<span class="c1">#                 relations = para_relations[relation_list_idx]</span>
<span class="c1">#                 sent_parsed_result1, sent_eventualities1 = parsed_result[arg1_sent_idx], para_eventualities[arg1_sent_idx]</span>
<span class="c1">#                 sent_parsed_result2, sent_eventualities2 = parsed_result[arg2_sent_idx], para_eventualities[arg2_sent_idx]</span>
<span class="c1">#                 arg1_eventualities = [e for e in sent_eventualities1 if \</span>
<span class="c1">#                     similarity_func(sent_parsed_result1, arg1, e, threshold=threshold, conn_indices=conn_indices)]</span>
<span class="c1">#                 arg2_eventualities = [e for e in sent_eventualities2 if \</span>
<span class="c1">#                     similarity_func(sent_parsed_result2, arg2, e, threshold=threshold, conn_indices=conn_indices)]</span>
<span class="c1">#                 cnt = 0.0</span>
<span class="c1">#                 if len(arg1_eventualities) &gt; 0 and len(arg2_eventualities) &gt; 0:</span>
<span class="c1">#                     cnt = 1.0 / (len(arg1_eventualities) * len(arg2_eventualities))</span>
<span class="c1">#                 for e1 in arg1_eventualities:</span>
<span class="c1">#                     heid = e1.eid</span>
<span class="c1">#                     for e2 in arg2_eventualities:</span>
<span class="c1">#                         teid = e2.eid</span>
<span class="c1">#                         existed_relation = False</span>
<span class="c1">#                         for relation in relations:</span>
<span class="c1">#                             if relation.hid == heid and relation.tid == teid:</span>
<span class="c1">#                                 relation.update({sense: cnt})</span>
<span class="c1">#                                 existed_relation = True</span>
<span class="c1">#                                 break</span>
<span class="c1">#                         if not existed_relation:</span>
<span class="c1">#                             relations.append(Relation(heid, teid, {sense: cnt}))</span>

<span class="c1">#         if in_order:</span>
<span class="c1">#             if output_format == &quot;Relation&quot;:</span>
<span class="c1">#                 return para_relations</span>
<span class="c1">#             elif output_format == &quot;triplet&quot;:</span>
<span class="c1">#                 return [sorted(chain.from_iterable([r.to_triplets() for r in relations])) \</span>
<span class="c1">#                     for relations in para_relations]</span>
<span class="c1">#         else:</span>
<span class="c1">#             if output_format == &quot;Relation&quot;:</span>
<span class="c1">#                 rid2relation = dict()</span>
<span class="c1">#                 for relation in chain(*para_relations):</span>
<span class="c1">#                     if relation.rid not in rid2relation:</span>
<span class="c1">#                         rid2relation[relation.rid] = deepcopy(relation)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         rid2relation[relation.rid].update(relation)</span>
<span class="c1">#                 return sorted(rid2relation.values(), key=lambda r: r.rid)</span>
<span class="c1">#             if output_format == &quot;triplet&quot;:</span>
<span class="c1">#                 return sorted([r.to_triplets() for relations in para_relations for r in relations])</span>

<span class="c1">#     def extract_from_parsed_result(self, parsed_result,</span>
<span class="c1">#                                    eventuality_output_format=&quot;Eventuality&quot;,</span>
<span class="c1">#                                    relation_output_format=&quot;Relation&quot;,</span>
<span class="c1">#                                    in_order=True, **kw):</span>
<span class="c1">#         if eventuality_output_format not in [&quot;Eventuality&quot;, &quot;json&quot;]:</span>
<span class="c1">#             raise NotImplementedError(&quot;Error: extract_eventualities only supports Eventuality or json.&quot;)</span>
<span class="c1">#         if relation_output_format not in [&quot;Relation&quot;, &quot;triplet&quot;]:</span>
<span class="c1">#             raise NotImplementedError(&quot;Error: extract_relations only supports Relation or triplet.&quot;)</span>

<span class="c1">#         if not isinstance(parsed_result, (list, tuple, dict)):</span>
<span class="c1">#             raise NotImplementedError</span>
<span class="c1">#         if isinstance(parsed_result, dict):</span>
<span class="c1">#             is_single_sent = True</span>
<span class="c1">#             parsed_result = [parsed_result]</span>
<span class="c1">#         else:</span>
<span class="c1">#             is_single_sent = False</span>

<span class="c1">#         syntax_tree_cache = kw.get(&quot;syntax_tree_cache&quot;, dict())</span>

<span class="c1">#         len_sentences = len(parsed_result)</span>
<span class="c1">#         para_eventualities = [list() for _ in range(len_sentences)]</span>
<span class="c1">#         para_relations = [list() for _ in range(2*len_sentences-1)]</span>

<span class="c1">#         connectives = self.conn_extractor.extract(parsed_result, syntax_tree_cache)</span>
<span class="c1">#         SS_connectives, PS_connectives = self.argpos_classifier.classify(parsed_result, connectives, syntax_tree_cache)</span>
<span class="c1">#         SS_connectives = self.ss_extractor.extract(parsed_result, SS_connectives, syntax_tree_cache)</span>
<span class="c1">#         PS_connectives = self.ps_extractor.extract(parsed_result, PS_connectives, syntax_tree_cache)</span>
<span class="c1">#         connectives = self.explicit_classifier.classify(parsed_result, SS_connectives+PS_connectives, syntax_tree_cache)</span>
<span class="c1">#         connectives.sort(key=lambda x: (x[&quot;sent_idx&quot;], x[&quot;indices&quot;][0] if len(x[&quot;indices&quot;]) &gt; 0 else -1))</span>

<span class="c1">#         for connective in connectives:</span>
<span class="c1">#             conn_indices = connective.get(&quot;indices&quot;, None)</span>
<span class="c1">#             arg1 = connective.get(&quot;arg1&quot;, None)</span>
<span class="c1">#             arg2 = connective.get(&quot;arg2&quot;, None)</span>
<span class="c1">#             sense = connective.get(&quot;sense&quot;, None)</span>
<span class="c1">#             if conn_indices and arg1 and arg2:</span>
<span class="c1">#                 arg1_sent_idx = arg1[&quot;sent_idx&quot;]</span>
<span class="c1">#                 arg2_sent_idx = arg2[&quot;sent_idx&quot;]</span>
<span class="c1">#                 senses = []</span>
<span class="c1">#                 if arg1_sent_idx == arg2_sent_idx:</span>
<span class="c1">#                     senses.append(&quot;Co_Occurrence&quot;)</span>
<span class="c1">#                 if sense and sense != &quot;None&quot;:</span>
<span class="c1">#                     senses.append(sense)</span>
<span class="c1">#                 if len(senses) == 0:</span>
<span class="c1">#                     continue</span>
<span class="c1">#                 relation_list_idx = arg1_sent_idx if arg1_sent_idx == arg2_sent_idx else arg1_sent_idx + len_sentences</span>
<span class="c1">#                 relations = para_relations[relation_list_idx]</span>
<span class="c1">#                 sent_parsed_result1, sent_eventualities1 = parsed_result[arg1_sent_idx], para_eventualities[arg1_sent_idx]</span>
<span class="c1">#                 sent_parsed_result2, sent_eventualities2 = parsed_result[arg2_sent_idx], para_eventualities[arg2_sent_idx]</span>
<span class="c1">#                 arg1_eventualities = self._extract_eventualities_from_clause(sent_parsed_result1, arg1[&quot;indices&quot;])</span>
<span class="c1">#                 arg2_eventualities = self._extract_eventualities_from_clause(sent_parsed_result2, arg2[&quot;indices&quot;])</span>
<span class="c1">#                 self._append_new_eventuaities_to_list(sent_eventualities1, arg1_eventualities)</span>
<span class="c1">#                 self._append_new_eventuaities_to_list(sent_eventualities2, arg2_eventualities)</span>

<span class="c1">#                 cnt = 0.0</span>
<span class="c1">#                 if len(arg1_eventualities) &gt; 0 and len(arg2_eventualities) &gt; 0:</span>
<span class="c1">#                     cnt = 1.0 / (len(arg1_eventualities) * len(arg2_eventualities))</span>
<span class="c1">#                 for e1 in arg1_eventualities:</span>
<span class="c1">#                     heid = e1.eid</span>
<span class="c1">#                     for e2 in arg2_eventualities:</span>
<span class="c1">#                         teid = e2.eid</span>
<span class="c1">#                         is_existed = False</span>
<span class="c1">#                         for relation in relations:</span>
<span class="c1">#                             if relation.hid == heid and relation.tid == teid:</span>
<span class="c1">#                                 relation.update({sense: cnt for sense in senses})</span>
<span class="c1">#                                 is_existed = True</span>
<span class="c1">#                                 break</span>
<span class="c1">#                         if not is_existed:</span>
<span class="c1">#                             relations.append(Relation(heid, teid, {sense: cnt for sense in senses}))</span>

<span class="c1">#         if in_order:</span>
<span class="c1">#             if eventuality_output_format == &quot;json&quot;:</span>
<span class="c1">#                 para_eventualities = [[eventuality.encode(encoding=None) for eventuality in sent_eventualities] \</span>
<span class="c1">#                     for sent_eventualities in para_eventualities]</span>
<span class="c1">#             if relation_output_format == &quot;triplet&quot;:</span>
<span class="c1">#                 relations = [list(chain.from_iterable([relation.to_triplet() for relation in sent_relations])) \</span>
<span class="c1">#                     for sent_relations in para_relations]</span>
<span class="c1">#             if is_single_sent:</span>
<span class="c1">#                 return para_eventualities[0], para_relations[0]</span>
<span class="c1">#             else:</span>
<span class="c1">#                 return para_eventualities, para_relations</span>
<span class="c1">#         else:</span>
<span class="c1">#             eid2eventuality = dict()</span>
<span class="c1">#             for eventuality in chain.from_iterable(para_eventualities):</span>
<span class="c1">#                 eid = eventuality.eid</span>
<span class="c1">#                 if eid not in eid2eventuality:</span>
<span class="c1">#                     eid2eventuality[eid] = deepcopy(eventuality)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     eid2eventuality[eid].update(eventuality)</span>
<span class="c1">#             if eventuality_output_format == &quot;Eventuality&quot;:</span>
<span class="c1">#                 eventualities = sorted(eid2eventuality.values(), key=lambda e: e.eid)</span>
<span class="c1">#             elif eventuality_output_format == &quot;json&quot;:</span>
<span class="c1">#                 eventualities = sorted([eventuality.encode(encoding=None) for eventuality in eid2eventuality.values()], key=lambda e: e[&quot;eid&quot;])</span>

<span class="c1">#             rid2relation = dict()</span>
<span class="c1">#             for relation in chain.from_iterable(para_relations):</span>
<span class="c1">#                 if relation.rid not in rid2relation:</span>
<span class="c1">#                     rid2relation[relation.rid] = deepcopy(relation)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     rid2relation[relation.rid].update(relation)</span>
<span class="c1">#             if relation_output_format == &quot;Relation&quot;:</span>
<span class="c1">#                 relations = sorted(rid2relation.values(), key=lambda r: r.rid)</span>
<span class="c1">#             elif relation_output_format == &quot;triplet&quot;:</span>
<span class="c1">#                 relations = sorted(chain.from_iterable([relation.to_triplets() for relation in rid2relation.values()]))</span>
<span class="c1">#             return eventualities, relations</span>

<span class="c1">#     def _extract_clauses(self, parsed_result, syntax_tree_cache):</span>
<span class="c1">#         para_arguments = [set() for _ in range(len(parsed_result))]</span>
<span class="c1">#         connectives = self.conn_extractor.extract(parsed_result, syntax_tree_cache)</span>
<span class="c1">#         para_connectives = [set() for _ in range(len(parsed_result))]</span>
<span class="c1">#         for connective in connectives:</span>
<span class="c1">#             sent_idx, indices = connective[&quot;sent_idx&quot;], tuple(connective[&quot;indices&quot;])</span>
<span class="c1">#             para_connectives[sent_idx].add(indices)</span>
<span class="c1">#         for sent_idx, sent_parsed_result in enumerate(parsed_result):</span>
<span class="c1">#             sent_connectives = para_connectives[sent_idx]</span>
<span class="c1">#             sent_arguments = para_arguments[sent_idx]</span>

<span class="c1">#             if sent_idx in syntax_tree_cache:</span>
<span class="c1">#                 syntax_tree = syntax_tree_cache[sent_idx]</span>
<span class="c1">#             else:</span>
<span class="c1">#                 syntax_tree = syntax_tree_cache[sent_idx] = SyntaxTree(sent_parsed_result[&quot;parse&quot;])</span>

<span class="c1">#             # more but slower</span>
<span class="c1">#             # for indices in powerset(sent_connectives):</span>
<span class="c1">#             #     indices = set(chain.from_iterable(indices))</span>
<span class="c1">#             #     sent_arguments.update(get_clauses(sent_parsed_result, syntax_tree, sep_indices=indices))</span>
<span class="c1">#             sent_arguments.update(get_clauses(sent_parsed_result, syntax_tree, sep_indices=set(chain.from_iterable(sent_connectives))))</span>
<span class="c1">#         return para_arguments</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, KnowComp.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>